장고 관리자

슈퍼유저
    python manage.py createsuperuser 명령으로 슈퍼유저 생성
    생성 후 로컬 서버 구동하고 /admin 페이지에 접속하면 관리자 페이지에 접속 가능

모델 관리
    아까 만든 Question 모델을 관리자에 등록

    from django.contrib import admin
    from .models import Question
    admin.site.register(Question)

    관리자 화면에서 subject로 검색하는 방법
    class QuestionAdmin(admin.ModelAdmin):
        search_fields = ['subject']

    admin.site.register(Question, QuestionAdmin)
    Question 모델에 세부 기능을 추가할 수 있는 QuestionAdmin 클래스를 생성하고,
    제목 검색을 위해 search_fields 속성에 subject를 추가했다.

질문 목록
    질문 목록 데이터는 Question.objects.order_by('-create_date') 로 얻을 수 있다. order_by는 조회 결과를 정렬하는 함수이다. order_by('-create_date')는 작성일시 역순으로 정렬하라는 의미이다. 
    - 기호가 붙어 있으면 역방향, 없으면 순방향 정렬을 의미한다. 
    게시물은 보통 최신순으로 보기 때문에 작성일시의 역순으로 정렬했다.

    render 함수는 파이썬 데이터를 템플릿에 적용하여 HTML로 반환하는 함수이다. 
    즉, 위에서 사용한 render 함수는 질문 목록으로 조회한 question_list 데이터를 pybo/question_list.html 파일에 적용하여 HTML을 생성한후 리턴한다.

템플릿 디렉터리
    이제 render 함수에서 사용한 pybo/question_list.html 템플릿 파일을 작성해야 한다. 
    하지만 템플릿 파일을 작성하기 전에 템플릿 파일을 저장할 디렉터리를 먼저 만들어야 한다. 
    템플릿을 저장할 디렉터리는 config/settings.py 파일의 TEMPLATES 항목에 설정해야 한다.
    question_list.html 파일은 템플릿 태그를 이용해서 작성하는데, 태그는 {% ~ %} 로 구성되어 있는데 이해하기 쉬움

    if문 - endif로 닫아줘야함
    {% if 조건문1 %}
        <p>조건문1에 해당되는 경우</p>
    {% elif 조건문2 %}
        <p>조건문2에 해당되는 경우</p>
    {% else %}
        <p>조건문1, 2에 모두 해당되지 않는 경우</p>
    {% endif %}

    반복문 - endfor로 닫아줘야함
    {% for item in list %}
        <p>순서: {{ forloop.counter }} </p>
        <p>{{ item }}</p>
    {% endfor %}

    객체 출력
    {{객체}}

    속성 출력
    {{객체.속성}}

위처럼 만들어서 질문을 들어가면 
http://localhost:8000/pybo/2/ 이런 주소가 나오며 404 에러가 발생한다.
-> 매핑이 안되어 있기 때문 
url이 동작할 수 있도록 매핑해줘야함

pybo/urls.py 파일에 path('<int:question_id>/', views.detail), 를 추가해줬다.
매핑 룰에 의해 question_id가 저장되고 views.detail 함수가 실행된다.

views.detail함수
    def detail(request, question_id):
        question =  get_object_or_404(Question, pk=question_id)
        context = {'question': question}
        return render(request, 'pybo/question_detail.html', context)
    
    pk는 primary key 라는 의미이며, 매개변수 question_id에는 URL 매핑시 저장된 question_id가 전달된다.
    즉, http://localhost:8000/pybo/2/ 페이지가 요청되면 매개변수 question_id에 2가 세팅되어 detail 함수가 실행된다.


URL 하드 코딩
개발 하다보면 URL 링크의 구조가 자주 변경될 수 있는데, 이 경우 일일히 변경해야하는 어려움 발생
-> URL 별칭 사용

URL 별칭
URL 매핑에 name 속성을 부여한다.

    path('', views.index),
    path('<int:question_id>/', views.detail), 를 

    path('', views.index,name='index'),
    path('<int:question_id>/', views.detail,name='detail') 처럼 변경

    변경된 후, 사용할 때 /pybo/{{ question.id }} 링크를 {% url 'detail' question.id %}로 변경
    url 태그는 detail이라는 이름을 가진 URL 패턴을 찾아 question.id 의 값을 question_id로 대체하여 사용

        동작 과정
            URL 패턴 찾기: Django는 name='detail'로 정의된 URL 패턴을 검색합니다.
            인수 대입: URL 패턴에서 <int:question_id>/ 부분이 있는데, 이 패턴의 question_id 자리에 question.id 값이 대입됩니다.
            URL 생성: 최종적으로 /pybo/1/와 같은 형태의 URL이 생성됩니다(여기서 1은 question.id의 값).

URL 네임스페이스
서로 다른 앱에서 동일한 URL 별칭을 사용하면 에러가 발생하기 때문에 app_name 변수를 지정해줘야함
app_name을 pybo로 정했다면 {%url 'pybo:detail' question.id  %}로 변경

답변 등록 폼
    <form action="{% url 'pybo:answer_create' question.id %}" method="post">
    {% csrf_token %}
    <textarea name="content" id="content" rows="15"></textarea>
    <input type="submit" value="답변등록">
    </form>

    form 태그 바로 밑에 보이는 {% csrf_token %}은 보안에 관련된 항목으로 form으로 전송한 데이터가 실제 웹 페이지에서 작성한 데이터인지를 판단
    form 태그 바로 밑에 {% csrf_token %} 태그를 항상 위치시켜야 한다.

    def answer_create(request, question_id):
        question = get_object_or_404(Question, pk=question_id)
        question.answer_set.create(content=request.POST.get('content'), create_date=timezone.now())
        return redirect('pybo:detail', question_id=question.id)
    
    답변 등록시 텍스트창에 입력한 내용은 answer_create 함수의 첫번째 매개변수인 request 객체를 통해 읽을 수 있다.
    request.POST.get('content')는 post로 전달된 form 중에서 content 값을 읽어온다는 의미이다.

    답변을 생성하기 위해 question.answer_set.create 를 사용하였다. question.answer_set은 질문의 답변을 의미한다.
    Question과 Answer 모델은 서로 ForeignKey 로 연결되어 있기때문에 이처럼 사용할 수 있다.

답변 조회
    답변 조회하기 위한 질문 상세
    <h5>{{ question.answer_set.count }}개의 답변이 있습니다.</h5>
    <div>
        <ul>
        {% for answer in question.answer_set.all %}
            <li>{{ answer.content }}</li>
        {% endfor %}
        </ul>
    </div>
    for문으로 모두 출력

    

