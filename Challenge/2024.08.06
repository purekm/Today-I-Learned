장고 개발 흐름 정리

1. 브라우저에서 로컬 서버로 페이지를 요청
    로컬 서버 구동 python manage.py runserver
    (localhost:8000/pybo 라고 요청시 오류가 나올 것)
    Page not Found가 발생하면 config/urls.py 에 pybo/ 매핑

2. urls.py 파일에서 /pybo URL 매핑을 확인하여 views.py 파일의 index 함수 호출
    from pybo import views
    path('pybo/', views.index), 를 urls.py 파일에 작성해주면 매핑
    이후 views.py 파일에서 index 함수 추가
    def index(request):
        return HttpResponse("안녕하세요 pybo에 오신것을 환영합니다.")

3. 호출한 결과를 브라우저에 반영

위까지만 진행하면 매핑을 추가할 때마다 config/urls.py 파일을 수정해야 한다.
-> config/urls.py 파일에서 from django.urls import path, include로 변경하고
    pybo/ URL에 대한 매핑을 path('pybo/', views.index) 에서 path('pybo/', include('pybo.urls'))로 수정
pybo/로 시작하는 페이지를 요청하면 이제 pybo/urls.py 파일의 매핑 정보를 읽어서 처리한다는 의미이다.
따라서 pybo/로 시작하는 URL을 추가해야 할 때 pybo/urls.py 파일만 수정하면 된다.

from django.urls import path

from . import views

urlpatterns = [
    path('', views.index),
]
처럼 urls.py 파일을 작성해주면 pybo/ URL은 다음처럼 config/urls.py 파일에 pybo/ 가 생략된 ''이 사용되었다.
config/urls.py 파일에서 이미 pybo/로 시작하는 URL이 먼저 매핑되었기 때문에 '/pybo' + '' 으로 'pybo/'가 된 것이다. 

장고의 데이터베이스
데이터베이스를 MySQL에서 오라클로 변경하면 프로그램에서 사용한 쿼리문을 모두 해당 데이터베이스의 규칙에 맞게 수정해야하는 어려움 발생
ORM(Object Relational Mapping)을 사용하면 데이터베이스의 테이블을 모델화하여 SQL 방식의 단점이 삭제됨.

모델 작성
    Question 모델
    Subject - 제목
    Content - 내용
    create_date - 질문 작성 일시

    Answer 모델
    question - 질문
    content - 내용
    create_date - 답변 일시

    makemigrations 명령어는 모델을 생성하거나 변화가 있을 경우 사용한다. (속성에 변화가 있을 때)
    처음에 makemigrations로 테이블 작업을 수행하기위한 작업 파일을 생성
    실제 테이블 작업은 migrate 명령을 통해서만 가능
    sqlmigrate 명령으로 실행되는 쿼리 조회 가능
    migrate 명령으로 실제로 실행

모델 사용
    장고 셸 실행하려면 python manage.py shell 명령을 실행하고
    모델들을 import 하고나서 각 모델들의 요소들을 정의
    정의한 요소들을 조회하려면 Question.objects.all()을 통해서 모든 데이터 확인
    
    조회할 때 제목은 id값 대신 subject 표시 가능
        def __str__(self):
            return self.subject


filter은 조건에 해당하는 데이터를 모두 리턴해 주기 대문에 QuerySet을 불러옴
filter을 사용하여 id값이 1인 Question 데이터 조회
Question.objects.filter(id=1)

id는 유일하니까 get 사용도 가능
get으로 조회할 경우 Question 모델 객체가 리턴됨
Question.objects.get(id=1)

Question.objects.filter(subject__contains='장고')을 통해서 문자열 포함 여부 확인 가능

Question 과 Answer의 질문과 답변을 작성
a = Answer(question=q, content='네 자동으로 생성됩니다.', create_date=timezone.now()) 처럼 작성

q.answer_set을 사용하면 질문에 연결된 답변을 가져올 수 있다. 
Question 모델에는 answer_set 이라는 속성이 없지만 Answer 모델에 Question 모델이 ForignKey로 연결되어 있기 때문에 q.answer_set 과 같은 역방향 접근이 가능하다.

질문 하나에는 여러개의 답변이 가능하므로 q.answer_set이 가능하지만 답변 하나에는 여러개의 질문이 있을 수 없으므로 a.question_set은 불가능하다. 
답변 하나에는 질문 하나만 가능하기 때문에 a.question만 가능하다.