고가용성
MasterNode도 여러 개 있을 수 있고 etcd도 여러개 있을 수 있는데, 이때 쓰기요청을 하면 일관성이 깨지지 않나?
=> 리더를 선출해서 리더만 쓰게 함

etcd의 경우 쿼럼이라는 개념이 중요함
쿼럼: 과반수인 노드 개수
노드 1개 or 2개는 그래서 필요가 없음
=> 최소 3개

결론적으로, 리더 1명이 쓰고, 쿼럼만큼의 노드가 있어야 정상적인 클러스터

클러스터를 정석에 맞게 쉽게 구성하려면 kubeadm을 사용
1. 클러스터 구성을 위해 프로비저닝된 여러 시스템 or VM이 필요
2. 한 노드를 master node, 다른 노드들을 worker node로 설정
3. 각 노드에 컨테이너 런타임 설치
4. 각 노드에 kubeadm 설치 
5. master node에서 초기화 진행 (kubeadm init)
6. Master node와 worker node간 네트워크 설정(pod network)
7. worker node를 클러스터에 조인 (kubeadm join)


Helm
kubernetes 패키지 매니저
install 하면 앱에 필요한 컴포넌트들을 한꺼번에 설치, 업그레이드, 삭제 가능

Helm3부터는 Tiller가 사라지고 클라이언트-서버 구조가 아님
Helm3 는 3-way strategy를 사용
=> helm2에서는 kubectl로 수정한건 revision에 반영되지 않았지만, helm3에서는 반영됨
=> helm3에서는 live 리소스를 읽어서 반영함

Components
cli
Chart: 파일의 모음으로, 알아야 하는 모든 지침이 포함되어 있음
- Chart.yaml: 차트에 대한 메타데이터
- - Helm2는 apiVersion: v1, Helm3는 apiVersion: v2
- values.yaml: 차트의 기본값 
rleases: Chart가 설치된 인스턴스로, 릴리스내에 여러 개의 리비전을 가질 수 있음
- install 할때 릴리스를 설치하는데, 독립적으로 추적할 수 있으므로 릴리스를 작성하는게 좋음
- helm install release-name chart-name
metadata: 차트에 대한 정보로, 쿠버네티스 시크릿으로 저장됨
repository: 차트가 저장된 곳(공식 저장소: https://artifacthub.io/)

템플리팅
yaml 파일을 만들 때, 다른 파일의 값을 참조하기 위한 방법
values.yaml 파일에 값을 정의해두고, 템플릿 파일에서 {{ .Values.키이름 }} 으로 참조

Helm 명령어
--set 변수이름=값
- Helm명령어를 사용하여 환경변수 또한 수정 가능

helm pull: repo에 있는 차트 로컬로 다운로드
-  --untar: 압축을 해제한 상태로 폴더형태로 저장

helm repo: 레포 관련
- --add 이름 URL: 레포 추가
- --update: 레포 업데이트
- --list: 레포 리스트

helm search: 차트 검색
helm install: 차트 설치
- helm install 릴리스이름 차트이름(repo name/chart name)

Helm Lifecycle management
helm history 릴리스이름: 릴리스 히스토리 확인
helm rollback 릴리스이름 리비전번호: 특정 리비전으로 롤백 
rollback시 모든 설정을 리비전 1의 상태로 되돌림, 기술적으로 리비전1로 되돌아가는 것은 아니고 새로운 리비전 3으로 생성됨

Kustomize
base와 overlay 개념
base: 공통으로 사용할 리소스 정의
overlay: 환경별로 덮어쓸 리소스 정의
kustomization.yaml 파일에 리소스와 패치를 정의하는 형태로, 직접 YAML을 작성
kustomization 파일에는 관리해야하는 리소스 목록과 패치 방법이 정의됨

kustomize build 를 사용하면 kustomization.yaml 파일을 읽어서 최종 YAML을 생성
base, overlay 모두 적용된 최종 YAML을 출력
적용이 아니라 출력이므로, 따로 적용해줘야 함
kustomize build k8s/ : k8s/ 경로에 있는 kustomization.yaml 파일을 읽어서 최종 YAML 출력

- kustomize build k8s/ | kubectl apply -f - : 최종 YAML을 kubectl로 적용
- kubectl apply -k k8s/ : kubectl에서 kustomize 기능을 사용하여 k8s/ 경로의 kustomization.yaml 파일을 읽어서 적용   

삭제하고 싶으면 apply -> delete

Transformer
kustomization.yaml 파일에서 transformer를 정의하여 리소스에 공통으로 적용할 수 있는 기능
예: 네임스페이스, 라벨, 어노테이션 등을 공통으로 정의하기 위해 사용
Helm 쓰기 좋은 상황

Patch
kustomize에서 특정 리소스들을 대상으로 패치를 적용할 수 있는 기능으로, transformer보다 세밀한 제어가 가능
patch는 target, patch 내용으로 구성
json patch 형식
- target:
    kind: Deployment
    name: my-app
  patch: | -
  - op: replace
    path: /spec/replicas
    value: 5 
예시에서 patch는 spec.replicas를 5로 바꿔달라고 하는 것

strategy merge patch 형식
patches:
  - patch: | -
        apiVersion: apps/v1
        kind: Deployment
        metadata:
            name: nginx
        spec:
            replicas: 3

apiVersion, kind, name을 기준으로 타겟 리소스를 찾고, spec.replicas를 3으로 바꿔달라는 것

patch 할 때는 위와같이 inline 방식으로도 할 수 있지만, 별도의 파일로 만들어서 참조할 수도 있음
add와 replace의 경우엔 strategy merge patch 방식에선 알아서 판단해주고, remove를 하려면 원하는 필드를 null로 설정

definition file을 보면 list들이 있는데, list 수정하는 법
json 방식에서는 path에 변경하려는 list의 인덱스를 지정 path: /spec/containers/0 처럼 사용
0 대신 -를 사용하면 젤 뒤의 인덱스를 뜻함
strategy merge patch 방식에서는 list의 항목을 구분하는 key를 지정
strategy merge patch 방식에서 삭제를 하고 싶으면, - $patch: delete 를 작성하고, 지우려는 key값을 작성


Overlay
Base와 patch를 조합하여 환경별로 다른 설정을 적용하는 방법
예: dev, stage, prod 환경별로 다른 설정을 적용하고 싶을 때
base: ../../base
patche: |-
  - op: replace
    path: /spec/replicas
    value: 2
위 예시는 base에 정의된 리소스에서 spec.replicas 값을 2로 바꾸는 패치를 적용하는 overlay

overlay는 base에 있는 파일 뿐만이 아니라, overlay 폴더 내에 별도의 리소스 파일도 추가 가능
=> 각 환경에 맞는 리소스 추가 가능
patch를 통해 base에 있는 리소스를 삭제하는 게 아닌 이상, base에 있는 리소스들은 기본적으로 존재함

간단 요약
Base를 만들고, Overlay를 만들어서 환경 별 설정을 다르게 관리하는 데 주로 overlay에서 patch+ transformer를 사용

Components
공통 기능을 모듈처럼 작성해놓은 것

Components를 가져와서 사용하려면 resources가 아닌, components 항목에 작성
만약 components의 kustomization 파일에서 base에 있는 리소스를 참조하고 있다면 bases 항목도 작성해줘야 함.
=> 하지만 만약 overlay에서 해당 components를 사용하면 base가 2번 참조되니까 에러남
=> components를 단독으로 apply 하지 말고, 항상 overlay base와 함께 조립해서 사용하는 용도로 사용해라


Redis, MySQL, Prometheus, Consul 같은 기성 오픈소스 앱 설치
설치/업그레이드/롤백을 한 명령으로 관리하고 싶을 때
팀에서 차트를 만들어서 배포 패키지로 쓰고 싶을 때

kustomize 쓰기 좋은 상황

우리 회사 서비스 YAML을 직접 관리하면서 dev / stage / prod 환경별로 약간씩만 다르게 쓰고 싶을 때
템플릿 언어 안 쓰고, YAML + 패치 개념만으로 깨끗하게 관리하고 싶을 때
GitOps(Argo CD, Flux 등)에서 base/overlay 패턴 많이 씀

logs, critcl, journalctl, systemctl 명령어로 로그 확인하기

kubectl logs
- pod 안에서 돌아가는 앱의 로그 확인

crictl
- 쿠버네티스가 망가졌을 때 pod의 로그 확인

journalctl
- kubelet, docker, containerd 등 시스템 서비스 로그 확인
- 예: journalctl -u kubelet -f