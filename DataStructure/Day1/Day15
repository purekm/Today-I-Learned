Sorting 알고리즘

Bubble Sort
인접한 두 개의 데이터를 비교하면셔 정렬을 진행하는 방식
간단하지만 비교 횟수를 생각해서 시간복잡도를 보면 O(n^2)이다. 
실제로 활용하기 부담스러운 정도의 성능...!

Selection Sort
초기상태에 있는 데이터들 중 최솟값을 찾아서 
결과를 나타내는 배열에 이동시켜주는 방식
선택정렬의 시간복잡도 또한 O(n^2)

Insertion Sort
정렬 완료된 부분과 정렬 완료되지 않은 부분으로 나누어 
정렬 안된 부분에 있는 데이터를 정렬 된 부분의 특정 위치에 삽입해가며 정렬해주는 방식
삽입정렬의 시간복잡도 또한 O(n^2)

이제부터 효율적인 정렬 알고리즘 
Heap Sort
루트노드에 우선순위가 가장 높은 노드가 있으므로 정렬 순서상 가장 앞선다.
힙의 루트를 지우며 배열에 저장해나가면 정렬 완료!
탐색할때의 시간복잡도 O(log n)
n개를 정렬해야하므로 최종적으로 O(nlog n)

Merge Sort
갯수가 1개가 될때까지 분할해주며 합칠때 비교연산을 하며 정렬을 해준다.
분할과정에서 하나씩 구분이 될때 둘로 나누는 과정을 반복하는 이유
-> 재귀적 구현을 위한 것
병합과정 log n
n개의 데이터 비교연산하면 총 O(nlog n)

Quick Sort
피벗을 기준으로 왼쪽과 오른쪽으로 정렬
피벗을 기준으로 나뉜 왼쪽과 오른쪽에 재귀적으로 피벗을 정하며 정렬
피벗이 가장 작은 값이 되어버리면 O(n^2)이지만 
quick sort는 약간의 예외로 O(nlog n)으로 생각!
O(nlog n)의 복잡도를 가지는 다른 정렬 알고리즘과 비교했을 때 평균적으로 가장 빠름.
