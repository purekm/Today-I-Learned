# 운영체제의 역할

운영체제(OS, Operating System)는 **컴퓨터 하드웨어와 소프트웨어를 관리하는 핵심 소프트웨어**이다. 주요 역할은 다음과 같다.

## 1. 시스템 자원 관리 및 스케줄링
- CPU, 메모리, 디스크, 네트워크 등의 **자원을 효율적으로 관리**하고, **작업 우선순위를 조정**하여 실행 성능을 극대화함.

## 2. 다중 사용자 환경 지원
- 여러 사용자가 동시에 시스템에 접속하여 독립적으로 작업할 수 있도록 지원함.
- 사용자 계정, 권한 관리 등을 통해 충돌 없이 운영됨.

## 3. 보안 및 접근 제어
- 사용자 계정을 관리하고, 권한을 부여하여 **시스템 보안을 유지**함.
- 파일 접근 제어, 암호화, 방화벽 등의 기능을 제공.

## 4. 파일 시스템 관리
- 데이터를 저장하고 관리하는 파일 시스템을 제공하여, **효율적인 데이터 저장 및 검색을 가능**하게 함.

## 5. 네트워크 기능 제공
- 시스템 간 데이터 전송을 위한 **네트워크 인터페이스 및 프로토콜을 지원**하여, 인터넷 및 내부 네트워크 연결을 가능하게 함.

---

# 리눅스의 특징

리눅스는 **Unix 기반의 오픈소스 운영체제**로, 다음과 같은 강점을 갖고 있다.

## 1. 다중 사용자 지원
- 여러 사용자가 동시에 시스템에 접속하여 독립적인 작업을 수행할 수 있음.

## 2. 다중 작업(Multitasking)
- 여러 프로세스를 동시에 실행하여 **성능과 효율성을 극대화**할 수 있음.

## 3. 이식성(Portability)
- 다양한 플랫폼(PC, 서버, 모바일, 임베디드)에서 실행 가능하며, 하드웨어 아키텍처에 구애받지 않음.

## 4. 안정성 및 보안성
- Unix 기반으로 설계되어 **높은 보안성과 안정성**을 제공하며, 정기적인 패치 및 업데이트가 이루어짐.

## 5. 가상화(Virtualization) 지원
- KVM, Xen, Docker 등 다양한 **가상화 기술을 지원**하여 효율적인 서버 운영 및 클라우드 환경 구축이 가능함.

## 6. 오픈소스(Open Source)
- **누구나 커널 및 소프트웨어를 수정하고 배포 가능**하며, 커뮤니티 중심으로 지속적으로 발전하고 있음.

---

# 리눅스의 역사 및 발전 과정

## 1. 단순 순차 처리 시스템 (Batch Processing System)
- 초창기 운영체제는 한 번에 하나의 작업만 실행할 수 있었음.

## 2. 다중 프로그래밍(Multiprogramming)
- 하나의 CPU에서 **여러 프로그램을 동시에 실행**할 수 있도록 개선됨.

## 3. 시분할(Time-sharing) 및 실시간 시스템
- 여러 사용자가 동시에 시스템을 사용할 수 있도록 지원하며, 실시간 응용 프로그램이 가능해짐.

## 4. 분산 네트워크 시스템
- 여러 컴퓨터가 네트워크를 통해 자원을 공유하는 **클러스터 및 클라우드 컴퓨팅 환경**으로 발전.

## 5. 모바일 및 임베디드 시스템
- 스마트폰, IoT 기기, 임베디드 장치에서 **리눅스를 기반으로 한 OS(Android, Raspbian 등)** 가 널리 활용됨.

---

# 정리

- **운영체제(OS)** 는 시스템 자원 관리, 사용자 지원, 보안, 파일 시스템, 네트워크 기능을 제공하는 핵심 소프트웨어다.
- **리눅스** 는 다중 사용자, 다중 작업, 높은 보안성, 가상화 지원, 오픈소스 등의 장점을 가진 Unix 계열 OS다.
- **리눅스의 발전 과정** 은 단순한 배치 처리 시스템에서 다중 프로그래밍, 네트워크 시스템, 모바일 및 임베디드 OS로 확장되었다.

리눅스는 높은 확장성과 안정성을 갖춘 강력한 운영체제이며, 서버, 클라우드, IoT 등 다양한 분야에서 필수적으로 사용되고 있다.

# 리눅스의 종류
## 1. Unix
- AT&T의 켄 톰슨(Ken Thompson), 데니스 리치(Dennis Ritchie)가 개발
- 다중 사용자, 다중 작업 지원

## 2. Linux
- 리누스 토발즈(Linus Torvalds)가 개발한 오픈소스 커널 기반 운영체제

## 3. 리눅스 기반 모바일 OS
- **Android** : 구글이 개발한 모바일 운영체제
- **Tizen** : 삼성, 인텔이 공동 개발한 오픈소스 운영체제

## 4. IVI(차량용) 운영체제
- **QNX** : 유닉스 기반 실시간 운영체제, 블랙베리(BlackBerry)가 개발. 자동차, 항공기, 산업용 시스템에서 사용
- **GENIVI** : 오픈소스 기반 IVI(차량용 인포테인먼트) 플랫폼, 리눅스 커널 기반

## 5. 웹 운영체제
- **Chrome OS** : 구글이 개발한 클라우드 기반 운영체제
- **WebOS** : 리눅스 기반 운영체제로, 주로 가전 제품에서 사용됨

---

# Shareware(평가판)
- 일정 기간 무료로 제공되며, 이후 유료로 전환되는 소프트웨어

# 리눅스 기초 개념

## 1. 리눅스 커널
- **리누스 토발즈**가 개발
- 오픈소스 방식이며, 누구나 수정 및 패키징하여 배포 가능

## 2. GNU 프로젝트
- **리처드 스톨만**이 주도
- 유닉스와 호환성을 가지면서 더 나은 기능을 제공하는 운영체제 개발
- 대표적인 GNU 소프트웨어:
  - **GCC** (GNU Compiler Collection)
  - **BASH** (Bourne Again Shell)
  - **EMACS** (텍스트 편집기)

## 3. FSF(Free Software Foundation)
- **리처드 스톨만**이 설립
- 자유 소프트웨어의 생산, 보급, 발전을 위한 비영리 단체 (Free는 "무료"가 아니라 "자유"를 의미)
- 자유 소프트웨어의 4대 원칙:
  - **소스 코드 공개**
  - **상업적 목적으로 사용 가능**
  - **코드 수정 가능**
  - **수정된 코드 배포 시 코드 공개 필수**


# 리눅스 주요 라이선스

## 1. GPL (General Public License)
- 소스코드 공개 필수
- 수정된 코드도 반드시 공개해야 함
- 독점 소프트웨어와 결합 불가
- 법적으로 자유 소프트웨어의 원칙을 제한할 수 없음

## 2. LGPL (Lesser General Public License)
- **리처드 스톨만**이 GPL의 강한 카피레프트를 완화한 라이선스
- 독립적인 프로그램에서도 사용 가능
- 자유 소프트웨어뿐만 아니라 **독점 소프트웨어에서도 사용 가능**
- LGPL이 적용된 라이브러리를 이용해 개발할 경우, **소스 코드 공개 의무 없음**

## 3. BSD (Berkeley Software Distribution)
- 소스코드 수정 후 **제한 없이 배포 가능**
- **2차 저작물에 대한 소스코드 공개 의무 없음**
- **상용 소프트웨어에서도 사용 가능**

## 4. Apache License
- 누구나 소프트웨어를 자유롭게 다운로드하고 수정 가능
- **수정 후 재배포 시 소스코드를 공개할 의무 없음**
- **재배포 시 반드시 Apache License 2.0을 포함해야 함**

## 5. MPL (Mozilla Public License)
- MPL이 적용된 소스코드는 **오픈소스여야 하지만, 결합된 다른 소스코드는 공개 의무 없음**

---

# 라이선스 비교

** 2차 저작물 소스코드 공개 의무:**  
- **GPL, LGPL, MPL** (L로 끝나는 라이선스는 공개 의무 있음)

** 독점 소프트웨어와 결합 가능 여부:**  
- **GPL만 불가능**, 나머지는 모두 가능

# 리눅스 배포판

## 1. 슬랙웨어(Slackware) 계열
- **SuSE**: 독일에서 개발, YaST(Yet another Setup Tool) 유틸리티 제공
- **Vector Linux**: 슬랙웨어 기반의 경량 배포판

## 2. Debian 계열
- **dpkg -> apt** 패키지 관리 도구 사용
- 설치 및 업데이트 시 **의존성 확인 및 보안 업데이트 자동 수행**
- **이안 머독(Ian Murdock)**이 설립한 **Debian 프로젝트**
- **Debian**: 가장 안정적인 배포판 중 하나, 커뮤니티 주도로 운영
- **Knoppix**: Live CD 형태로 제공되는 Debian 기반 배포판
- **Corel Linux**: Corel에서 만든 GUI 중심 배포판(현재 중단)
- **Ubuntu**: GNOME 데스크톱 환경을 사용하는 대중적인 배포판
- **Linux Mint**: Ubuntu 기반의 사용자 친화적 배포판
- **Elementary OS**: 미려한 UI와 간결한 사용자 경험(macOS와 유사)
- **BackTrack -> Kali Linux**: 정보 보안 및 해킹 도구 포함

## 3. Red Hat 계열
- 가장 인기 있는 리눅스 배포판 계열 중 하나로, 패키지 관리 도구 **RPM, YUM** 사용
- **RHEL(Red Hat Enterprise Linux)**: 유료 배포판
- **CentOS**: RHEL의 무료 버전(현재는 RHEL과 통합됨)
- **Fedora**: 최신 기술을 테스트하는 Red Hat의 오픈소스 프로젝트
- **Oracle Linux**: Oracle에서 개발한 RHEL 기반 배포판

## 4. 아시아눅스(Asianux)
- **한국, 일본, 중국, 스리랑카** 등의 합작으로 개발된 리눅스 배포판

---

# 리눅스 배포판 개발 순서
1. **SLS (Softlanding Linux System)**
2. **Slackware**
3. **Debian**
4. **SuSE, Red Hat**
5. **CentOS**
6. **Ubuntu**

# 리눅스의 특징

## 1. 다중 사용자, 다중 처리 시스템
- 다수의 사용자가 동시에 접속하여 **각각 여러 개의 응용 프로그램을 실행**할 수 있음.

## 2. 공개된 시스템
- **커널 및 대부분의 내장 응용 프로그램의 소스 코드가 공개**되어 있으며, 누구나 수정 및 배포 가능.

## 3. 뛰어난 네트워크 환경
- 대부분의 **네트워크 프로토콜(TCP/IP, FTP, SSH, HTTP 등)을 지원**하여 서버 운영에 최적화됨.

## 4. 다양한 파일 시스템 지원
- **리눅스 고유의 파일 시스템(ext2, ext3, ext4)뿐만 아니라**, 아래의 파일 시스템도 지원함:
  - DOS의 **FAT**
  - Windows의 **FAT32 및 NTFS**
  - 상용 유닉스의 파일 시스템
  - **저널링 파일 시스템**(데이터 무결성을 보장하는 파일 시스템)

## 5. 뛰어난 이식성
- 운영체제의 핵심이 **C언어와 약간의 어셈블리 언어**로 작성되어 다양한 아키텍처에서 실행 가능.

## 6. 유연성 및 확장성
- 커널 및 시스템을 사용자의 필요에 맞게 **구성 및 확장 가능**.

## 7. 다양한 응용 프로그램 제공
- 기본적인 CLI(Command Line Interface) 도구부터 **GUI 기반의 데스크톱 환경(GNOME, KDE 등)**까지 지원.

## 8. 다양한 배포판
- 사용 목적에 맞게 **서버, 데스크톱, 임베디드 시스템 등 다양한 배포판**이 존재.

## 9. 유닉스 표준(POSIX) 준수
- **POSIX(Portable Operating System Interface) 표준을 준수**하여 유닉스와 높은 호환성을 유지.

---

# 리눅스의 단점

## 1. 특정 하드웨어에 대한 지원 부족
- 일부 최신 하드웨어 또는 전용 드라이버가 필요한 장비에 대한 **지원이 부족**할 수 있음.

## 2. 사용자의 숙련된 기술 요구
- GUI 환경이 발전했지만, 여전히 **CLI 명령어 및 시스템 관리에 대한 기본적인 이해가 필요**함.


# 리눅스 기술적 특징

## 1. 계층적 파일 구조
- **트리(Tree) 구조의 디렉터리 시스템**을 사용하여 데이터 및 파일을 체계적으로 관리.

## 2. 가상 메모리(SWAP)
- **하드디스크의 일부를 메모리처럼 사용**하는 기술.
- **Swapping**을 통해 메모리와 하드디스크 사이에서 데이터를 교환하여, 실제 메모리가 부족해도 새로운 프로그램을 실행할 수 있음.
- 사용하지 않는 프로그램을 하드디스크의 **가상 메모리(SWAP 공간)** 으로 보내고, 빈 공간에 새로운 프로그램을 로딩함.

## 3. 라이브러리
- **특정 기능을 하는 루틴들의 모임**으로, 프로그램이 공통 기능을 공유하여 **공간 효율성을 높임**.
- 동적 라이브러리와 정적 라이브러리로 구분됨.

## 4. 가상 콘솔
- **하나의 모니터에서 여러 개의 가상 화면을 제공**하는 기능.

## 5. 파이프 (Pipe)
- **프로세스 간 통신(IPC, Inter-Process Communication)** 을 위해 도입된 기능.
- 한 프로세스의 출력을 다른 프로세스의 입력으로 사용.
- 예시: `ls | grep "txt"`

## 6. 리다이렉션 (Redirection)
- **프로세스의 표준 입력/출력을 변경**하는 기능.
- 입력 리다이렉션(`<`), 출력 리다이렉션(`>`, `>>`)을 지원.
- 예시:
  - `ls > output.txt` (출력을 `output.txt` 파일에 저장)
  - `cat < input.txt` (파일을 입력으로 사용)

## 7. 모든 장치 파일화하여 관리
- **리눅스에서는 모든 장치(하드디스크, 프린터, 마우스 등)를 파일로 취급**하여 일관된 접근 방식을 제공.
- `/dev` 디렉터리 내에서 장치 파일을 관리.

---

# 리눅스 클러스터링

## 1. 고계산용 클러스터(HPC, High-Performance Computing)
- **고성능의 계산 능력을 제공**하는 클러스터.
- 여러 대의 컴퓨터를 병렬로 연결하여 **슈퍼컴퓨터 제작에 활용**.

## 2. 부하 분산 클러스터(LVS, Load Balancing Cluster)
- **대규모 서비스 제공을 위한 부하 분산 시스템**.
- 여러 대의 **리얼 서버(Real Server)와 부하 분산을 위한 로드 밸런서(Load Balancer)로 구성**.
- 웹 서버, 데이터베이스 서버 등에 사용.

## 3. 고가용성 클러스터(HA, High Availability)
- **지속적인 서비스 제공을 위한 클러스터**.
- 부하 분산 클러스터와 연동하여 고가용성을 보장.
- **Primary Node**: 정상적으로 부하 분산을 처리.
- **Backup Node**: Primary Node의 상태를 체크하다가, 이상 발생 시 서비스를 이어받음.

---

# 임베디드 시스템

- **마이크로컨트롤러, 마이크로프로세서, DSP 등을 내장**하여 특정 기능을 반복 수행하는 하드웨어와 소프트웨어를 결합한 시스템.
- 예: **스마트 가전, 자동차, 산업용 로봇, 의료기기** 등에 사용.

---

# 리눅스 활용 분야

## 1. 클라우드 컴퓨팅
- **인터넷 기반의 IT 서비스 환경**으로, 개인, 기업, 공공기관 등 외부 사용자에게 컴퓨팅 자원을 제공.
- 다양한 기반 기술(가상화, 분산 컴퓨팅, 네트워크 기술 등)이 융합되어 구현됨.
- **서로 다른 물리적 위치에 있는 컴퓨팅 자원을 가상화 기술을 통해 통합 제공**.

## 2. 빅데이터
- **대량의 정형 및 비정형 데이터 집합을 분석하여 가치를 추출**하는 기술.
- 주요 기술:
  - **자연어 처리(NLP)**
  - **데이터 마이닝**
  - **기계 학습(Machine Learning)**
  - **패턴 인식**
- 빅데이터 분석을 위한 오픈소스 프레임워크: **Hadoop**.
- IoT 기기와 연계: **아두이노(Arduino) 및 라즈베리파이(Raspberry Pi)**.


# 리눅스 시스템의 이해

## 리눅스와 하드웨어

### 1. 하드 디스크 드라이브
리눅스에서 디스크는 **장치 파일(/dev/)** 로 관리되며, 디스크 종류에 따라 명칭이 다름.

- **IDE 디스크**: `/dev/hda`, `/dev/hdb`
- **SCSI, SATA, USB 메모리, SSD**: `/dev/sda`, `/dev/sdb`

---

## RAID (Redundant Array of Independent/Inexpensive Disks)

RAID는 **여러 개의 하드디스크를 묶어 성능 향상 및 데이터 보호를 제공하는 기술**.

- **스트라이핑(Striping)**: 데이터를 블록 단위로 나누어 여러 개의 디스크에 라운드로빈 방식으로 저장.
- **미러링(Mirroring)**: 동일한 데이터를 여러 디스크에 중복 저장하여 장애 대비.
- **패리티(Parity) 또는 ECC 사용**: 오류 검사 및 복구 기능.

---

## RAID 종류

### 1. **RAID 0 (스트라이핑)**
- 데이터를 여러 디스크에 나누어 저장하여 **입출력 속도를 빠르게 향상**.
- **장점**: 성능이 뛰어남.
- **단점**: **디스크 하나만 고장 나도 데이터 전체 손실**.
- **최소 디스크 개수**: 2개 이상.

### 2. **RAID 1 (미러링)**
- 데이터를 **두 개의 디스크에 동일하게 저장**.
- **장점**: 하나의 디스크가 고장 나도 **정상 작동 가능**.
- **단점**: **저장 공간이 50%로 비효율적**.
- **최소 디스크 개수**: 2개.

### 3. **RAID 5 (패리티 기반)**
- **RAID 0의 성능 + RAID 1의 저장 공간 비효율성 해결**.
- 데이터를 스트라이핑하면서 **패리티 정보를 포함하여 저장**.
- **특징**:
  - **디스크 1개 고장 발생해도 사용 가능**.
  - **최소 3개의 디스크 필요**.
  - 패리티 저장 공간:
    - 디스크 3개(33%), 디스크 4개(25%), 디스크 5개(20%)  
  - **디스크 개수가 많을수록 저장 공간 효율성 증가**.
  - 쓰기 작업이 많지 않은 **다중 사용자 시스템에 적합**.

### 4. **RAID 6 (이중 패리티)**
- **RAID 5 + 2차 패리티 추가** → **2개의 디스크 오류에도 데이터 유지 가능**.
- **특징**:
  - **최소 4개의 디스크 필요**.
  - 복잡한 알고리즘으로 인해 **속도는 느리지만 신뢰성이 뛰어남**.
  - 패리티 저장 공간:
    - 디스크 4개(50%), 디스크 5개(40%), 디스크 6개(33%).

### 5. **RAID 0+1 (스트라이핑 후 미러링)**
- **RAID 0(속도) + RAID 1(안정성)**  
- **구성**:
  - 먼저 **RAID 0(스트라이핑)** 으로 빠른 데이터 저장.
  - 이후 **RAID 1(미러링)** 을 통해 장애 대비.
- **최소 디스크 개수**: **4개**.
- **단점**: RAID 0 그룹 하나라도 고장 나면 전체 데이터 손실 가능.

### 6. **RAID 10 (미러링 후 스트라이핑)**
- **RAID 1(안정성) + RAID 0(속도)**
- **구성**:
  - 먼저 **RAID 1(미러링)** 으로 데이터 보호.
  - 이후 **RAID 0(스트라이핑)** 으로 성능 향상.
- **최소 디스크 개수**: **4개**.
- **장점**: RAID 0+1보다 **데이터 보호 능력이 뛰어남**.

---

## LVM (Logical Volume Manager)

LVM은 **디스크 파티션을 유연하게 관리하는 기술**.

- 기존 파티션 방식과 달리 **사용 중에도 크기를 조정 가능**.
- **여러 개의 디스크를 하나로 묶을 수 있어 확장성이 뛰어남**.
- **크기가 다른 디스크도 하나의 볼륨으로 구성 가능**.

### LVM 구성 요소


 **물리적 볼륨 (PV, Physical Volume)** : 실제 하드디스크, SSD, 파티션 | `/dev/sda1`, `/dev/sdc1` |
 **볼륨 그룹 (VG, Volume Group)** : 여러 개의 PV를 묶어 하나의 큰 저장공간으로 만듦 | `vg_data` |
 **논리적 볼륨 (LV, Logical Volume)** : VG에서 사용자가 원하는 크기만큼 할당하여 생성 | `lv_home`, `lv_root` |
 **물리적 확장 (PE, Physical Extent)** : PV에서 나누어 사용하는 블록 영역 | 자동 설정됨 |


# 리눅스 구조

## 부트 매니저 (Boot Manager)

부트 매니저는 컴퓨터가 부팅될 때 **운영체제를 선택하고 실행하는 역할**을 담당한다.  
리눅스에서는 주로 **GRUB (GRand Unified Bootloader)** 가 사용된다.

---

## 1. GRUB (GRand Unified Bootloader)

### 주요 명령어 및 파일 경로

- **`grub2-mkconfig`**  
  - 환경 설정 변경 후 사용해야 하는 명령어.  
  - `-o` 옵션을 사용하여 **GRUB 환경 설정 파일을 생성**할 수 있음.  
  - 예시:
    ```bash
    grub2-mkconfig -o /boot/grub2/grub.cfg
    ```

- **GRUB 주요 환경 설정 파일 경로**  
  - `/boot/grub2/grub.cfg`  
    - GRUB의 핵심 설정 파일.
    - 셸 스크립트 형태로 작성됨.
  - `/etc/grub.d/`  
    - GRUB 부트 항목 관련 설정 파일이 저장된 디렉터리.
  - `/etc/default/grub`  
    - GRUB 기본 설정을 정의하는 파일.

---

## 2. GRUB 설정 주요 옵션

- **`GRUB_TIMEOUT=5`**  
  - 부트 화면에서 대기하는 시간을 **초 단위**로 지정.
  - 부팅 메뉴가 표시되는 시간을 설정함.
  - 예: `GRUB_TIMEOUT=5` → **5초 후 자동 부팅**

- **`GRUB_DEFAULT=0`**  
  - 기본적으로 선택될 부팅 항목을 지정.
  - `0`이면 첫 번째 운영체제, `1`이면 두 번째 운영체제 선택.
  - 예: `GRUB_DEFAULT=1` → **두 번째 항목으로 기본 부팅**

---

## 3. GRUB 설정 예시

예를 들어, 아래 설정이 적용된 `/etc/default/grub` 파일이 있다고 가정한다.

```bash
GRUB_TIMEOUT=100
GRUB_DEFAULT=1


# 리눅스 디렉터리 종류

리눅스는 **계층적 파일 시스템 구조**를 사용하며, 각 디렉터리는 특정 역할을 담당한다.

---

## 1. `/dev` - 장치(Device) 파일 관리
- **하드 디스크, CD-ROM, 터미널 등의 실제 장치를 파일 형태로 관리**.
- 예:
  - `/dev/sda` : 첫 번째 SCSI/SATA/USB 디스크
  - `/dev/hda` : 첫 번째 IDE 디스크
  - `/dev/null` : 모든 데이터를 버리는 특수 장치 파일
  - `/dev/tty` : 터미널 장치 파일

---

## 2. `/etc` - 시스템 설정 파일 저장
- 시스템의 **환경 설정 파일 및 부팅 관련 스크립트 파일** 저장.
- 하위에 **심볼릭 링크 설정**이 가능하여, 절대 경로 입력 시 디렉터리 생략 가능.

### 부팅 관련 설정 파일
- `/etc/grub.d` : **GRUB 부트로더의 메뉴 항목을 구성하는 스크립트 저장**.
- `/etc/default/grub` : **부팅 메뉴의 `timeout`, `default` 설정 파일**.

### 네임 리졸루션(Name Resolution)
- `/etc/hosts` : **DNS 조회 전에 IP 주소와 호스트명을 매핑하는 로컬 설정 파일**.
- `/etc/resolv.conf` : **시스템에서 사용할 DNS 서버 주소 지정**.

### 네트워크 설정
- `/etc/sysconfig/network` : **시스템의 Hostname, 기본 게이트웨이 등의 네트워크 정보 저장**.
- `/etc/sysconfig/network-scripts/` : **네트워크 인터페이스 관련 설정 파일 및 스크립트 저장**.

### 부팅 및 실행 레벨 관리
- `/etc/inittab` : **시스템 부팅 시 기본 실행 레벨 정의**.
- `/etc/init/rc.conf` : **각 실행 레벨 별 부팅 작업 설정**.
- `/etc/rc.d/rc.local` : **실행 레벨 2, 3, 5에서 마지막으로 실행되는 스크립트**, 부팅 시 특정 서비스 자동 시작에 사용됨.
- `/etc/rc.d/init.d`, `/etc/init.d`, `/etc/rc0.d ~ /etc/rc6.d` : **각 데몬(서비스)의 시작 및 종료를 제어하는 스크립트 저장**.

---


##3. /proc 
- 가상 파일 시스템으로 시스템에서 운영되고 있는 다양한 프로세스의 상태 정보
##4. /var 
- 시스템 운영  로그 파일과 스풀링 같은 가변적인 데이터 보관
##5. /lib 
- 시스템에서 사용되는 service 및 target 유닛 파일 

# 부팅과 셧다운

## 1. 로그인 메시지 관련 파일

리눅스에서 **사용자가 로그인할 때 출력되는 메시지를 설정하는 파일**들.

- **`/etc/issue`**  
  - 로그인 프롬프트 전에 출력되는 메시지 설정.
  - 시스템 정보 또는 경고 메시지를 표시 가능.

- **`/etc/issue.net`**  
  - **Telnet으로 접속할 경우 출력되는 메시지**.
  - 원격 접속 시 접속 안내문을 표시하는 데 사용됨.

- **`/etc/motd`** (Message of the Day)  
  - **로그인 성공 후 셸이 뜨기 전에 출력되는 메시지**.
  - 공지사항 또는 시스템 관련 정보를 제공할 때 사용됨.

- **`/etc/nologin.txt`**  
  - **로그인을 차단할 때 표시되는 메시지 설정**.
  - 시스템 유지보수 중 일반 사용자의 로그인을 막을 때 사용됨.

---

## 2. `init` - 실행 레벨 변경

리눅스에서는 `init` 프로세스가 **시스템의 실행 레벨을 관리**한다.  
`init` 명령을 사용하여 실행 레벨을 직접 변경할 수 있음.

- **`init 1`** : **단일 사용자 모드(싱글 유저 모드)**  
  - 루트 사용자만 접근 가능하며, 시스템 유지보수를 위해 사용.

- **`init 0`** : **즉시 시스템 종료**  
  - 모든 프로세스를 종료하고 시스템을 안전하게 종료.

- **`init 6`** : **즉시 시스템 재부팅**  
  - 시스템을 종료한 후 자동으로 다시 부팅.

---

# 파일 시스템

## 1. 디스크 장치 파일
- **`/dev/hda`** : IDE 디스크  
- **`/dev/sda`** : SCSI, SATA, USB, SSD 디스크  

---

## 2. 리눅스 파일 시스템의 발전 과정


**Minix** : 초기 리눅스에서 사용된 간단한 파일 시스템 
**ext2** : 기존 유닉스 파일 시스템 기반, 저널링 기능 없음 
**ext3** : ext2에 저널링 기능 추가 
**ext4** : ext3 대비 성능 개선, 대용량 파일 및 디스크 지원 
**XFS** : 고성능 저널링 파일 시스템, 대량의 데이터를 빠르게 처리 가능 

---

## 3. 저널링 파일 시스템

저널링 파일 시스템은 **파일 시스템에 변경사항을 반영하기 전에 "저널(로그)"에 기록하여 데이터 손상을 방지**하는 기술을 사용한다.

- 변경 사항이 기록되므로 **비정상 종료 후에도 데이터 무결성을 유지할 수 있음**.
- **저널링을 지원하는 파일 시스템**:
  - **ext3**
  - **ext4**
  - **XFS**
  - **JFS**
  - **ReiserFS**

---

## 4. Inode (아이노드)
- 유닉스 계열 파일 시스템에서 사용하는 **자료구조**.
- **파일의 메타데이터(소유권, 권한, 크기, 저장 위치 등)를 관리**.
- **각 파일은 하나의 Inode를 할당받아 관리됨**.
- 디렉터리는 Inode 번호를 통해 파일을 참조함.

```bash
ls -i filename  # 파일의 Inode 번호 확인
stat filename   # Inode 정보 및 메타데이터 확인

# X 윈도 (X Window System)

X 윈도 시스템은 **리눅스 및 유닉스 계열 운영체제에서 GUI(그래픽 사용자 인터페이스)를 제공하는 기본 프레임워크**이다.

---

## 1. X 윈도의 역사

- **XFree86** (2004년 이전)  
  - 리눅스 및 유닉스 계열에서 가장 널리 사용된 X 윈도 시스템.
  - 오픈소스로 개발되었으며, 대부분의 리눅스 배포판에서 사용됨.

- **X.org** (현재 표준)  
  - XFree86을 대체한 X 윈도 프로젝트.
  - 리눅스 및 유닉스 대부분이 **X.org 기반의 X 윈도 시스템을 사용**.

---

## 2. X 윈도의 특징

- **디스플레이 장치에 독립적**  
  - 특정 하드웨어나 운영체제에 의존하지 않고 동작 가능.

- **클라이언트/서버 구조 (네트워크 지향 시스템)**  
  - **X 서버 (X Server)**  
    - 화면에 그래픽을 표시하는 시스템.
    - 로컬뿐만 아니라 원격에서도 실행 가능.
  - **X 클라이언트 (X Client)**  
    - X 서버 위에서 동작하는 응용 프로그램(예: 웹 브라우저, 터미널 등).
  - **X Protocol**  
    - X 서버와 X 클라이언트 간의 메시지 형식 및 사용법을 정의.
    - 네트워크를 통해 원격 호스트와도 연결 가능.

---

## 3. Xlib & XCB (클라이언트 라이브러리)

- **Xlib**  
  - C 언어로 구현된 X 윈도 클라이언트 라이브러리.
  - X 클라이언트가 X 서버와 통신할 수 있도록 지원.

- **XCB (X C Binding)**  
  - Xlib을 대체하기 위해 등장.
  - **향상된 스레드 기능, 뛰어난 확장성**을 제공.

---

## X윈도 설치 및 실행
1. 실행
- systemctl get-default : 부팅 모드 확인 / 현재 시스템에 설정된 런 레벨 정보 확인
- systemctl set-default multi-user.target : 텍스트 모드로 부팅 (multi-user.target 대신 multi-user, runlevel3.target, runlevel3도 가능)
- systemctl set-default graphical.target :  X 윈도 모드로 부팅 (graphical.target 대신 graphical, runlevel5.target, runlevel5도 가능)
- startx : X윈도 실행시키는 스크립트

2. Display Manager (X 윈도 상에서 작동하는 프로그램)
- 사용자 로그인 및 세션 관리 역할 수행 / 로그인 창을 통해 사용자 인증 수행
- runlevel 5 일경우, 부팅 시 사용자 이름 및 암호 요청





