Synchronization Tools

프로세스는 동시에 실행 가능
busy waiting 상태 - 계속 CPU를 소모하는데 waiting중인 상태 
race condition - 경쟁 상태로 인해 원치않은 결과가 발생할 수 있기 때문에 상호 배타가 필수적 
critical section - 임계 구역으로, 공유 자원을 사용하는 구간을 나타냄

컴파일러는 비종속적인 두 명령어의 순서를 임의로 바꿀 수 있다.

Critical section 문제 해결책
1. 상호배제 
2. progress - 어떤 프로세스도 cs를 실행 중이지 않으면 , 대기중인 프로세스 중 하나는 선택되어야한다. 무기한 연기될 수 없음
3. bounded waiting - 한 프로세스가 cs에 들어가면 다른 프로세스가 cs에 들어가는 횟수는 제한되어야 한다.

OS는 커널이 선점 가능한지 여부에 따라 두가지 접근 방식을 취할 수 있다.
preemptive , Non preemptive로 나뉜다.

피터슨 solution

Synchronization Hardware
많은 시스템은 cs를 구현하기 위해 하드웨어 지원을 제공

단일 프로세서 - 인터럽트를 비활성화 가능

3가지 형태의 하드웨어 지원
1. 메모리 배리어
    strongly ordered - 프로세서의 메모리 수정이 즉시 다른 프로세서에게 보임
    weakly ordered - 메모리 수정이 다른 프로세서에게 즉시 보이지 않음

    while(!flag)
        memory_barrier();
    print x

    위의 경우에는 x값이 로딩되기 전에 flag 값이 먼저 로딩되는 것을 보장함 
    very low-level 이므로, 커널 개발자가 특별하게 상호 배타하는 경우만 사용

2. 하드웨어 명령어
    Test-and-Set
        while(test_and_set(&lock))
            리턴 값이 true면 cs에 다른 프로세스가 있다는 의미
            리턴 값이 false면 cs에 아무도 없다는 의미
                lock이 false면 cs에 들어가고 true로 바꿔 줌으로써 다른 프로세스가 cs에 들어오지 못하게 함
        while문에서 lock 획득을 계속 시도하고 있으므로 spin-lock
        spin-lock - lock을 얻기 위해 CPU 소모를 계속 하는 상태

    Compare-and-Swap
        while (compare_and_swap(&lock, expected, new_value) != 0)
            lock값과 expected의 값이 같으면 lock의 값을 new로 변경
            둘의 값이 다르면 변화 없음
            항상 lock의 original 값을 return
        while (compare_and_swap(&lock, 0, 1) != 0)
            처음엔 lock이 0이였다가, 한번 실행하면 lock이 1로 바껴서 대기상태로 바뀐다.
            처음에 실행되었던 프로세스가 lock 풀어주면 lock이 0으로 바껴서 다음 프로세스가 실행된다.
            lock 획득을 계속 시도하고 있기 때문에 spin-lock
            의미적으로 test-and-set과 동일

    Comapre-and-Exchange
        while (!compare_and_exchange(&lock, &expected, new_value))
            lock 값이 expected값과 일치하면 new_value로 바꾸고 return true
            일치하지 않으면 expected 값을 lock 값으로 바꾸고 return false
        while (!compare_and_exchange(&lock, &expected, 1)) 
            의미적으로 test_and_set과 동일하며, spin-lock 방식이다.
        
        waiting queue를 이용한 peterson 방식을 compare_and_swap 과 함께 사용하면
        CS에 순차적으로 들어가는 알고리즘 구현 가능

        
    
3. atomic 변수
    

