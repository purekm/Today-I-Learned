# Chapter 4 - Overview

## Objectives
1. 스레드의 기본 구성 요소 이해 및 프로세스와 비교
2. 멀티 스레딩의 장점과 구현할 때의 도전 과제
3. 스레딩에 대한 다양한 접근 방법 설명
4. 리눅스 운영 체제가 스레드를 어떻게 나타내는지 설명

## Multithreading and Applications

### 개요
요즘 대부분의 애플리케이션은 멀티스레딩 방식으로 구현됨. 애플리케이션 내에서 여러 작업은 별도의 스레드로 구현될 수 있음. 예를 들어, 화면 업데이트, 데이터 가져오기, 맞춤법 검사, 네트워크 요청 처리 등이 있음. 프로세스 생성은 무거운 작업인 반면, 스레드 생성은 가벼운 작업임. 대부분의 커널은 멀티스레드 방식으로 작동함.

![image](https://github.com/purekm/Today-I-Learned/assets/90774046/7eb50ef9-5c24-4dc8-bdf6-b84a9498e564)

### Single-thread vs Multithreaded
- 싱글 스레드는 단순히 프로세스라고 생각할 수 있음. 멀티스레드 프로세스는 독립적인 레지스터, 스택, 프로그램 카운터(PC)를 가지면서 코드, 데이터, 파일을 공유함.

## Multithreading의 장점

### 멀티스레드의 이점
1. **응답성(Responsiveness)**: 프로세스의 일부가 블록되어도 계속 실행될 수 있어서, 특히 사용자 인터페이스에 중요함.
2. **자원 공유(Resource Sharing)**: 스레드는 프로세스의 자원을 공유하므로, 공유 메모리나 메시지 전달 방식보다 자원 공유가 쉬움.
3. **경제성(Economy)**: 스레드 생성이 프로세스 생성보다 저렴하고, 스레드 전환이 문맥 전환(context switch)보다 오버헤드가 적음.
4. **확장성(Scalability)**: 프로세스가 멀티코어 구조의 장점을 활용할 수 있음.

### 병렬 처리 vs 병행 처리
- **병렬 처리(Parallelism)**: 시스템이 동시에 둘 이상의 작업을 수행할 수 있는 능력.
- **병행 처리(Concurrency)**: 둘 이상의 작업이 진행 중인 상태 (단일 프로세서/코어의 경우).

### Amdahl's Law
- Amdahl's 법칙은 애플리케이션의 병렬 및 직렬 컴포넌트를 고려하여 성능 향상을 평가함. 예를 들어, 애플리케이션이 75% 병렬로 구성된 경우, 2개의 코어를 사용하면 성능이 1.6배 향상될 수 있음. 코어 수가 증가해도 직렬 컴포넌트가 성능 향상을 제한함.

## Multithreading Models

### User Threads and Kernel Threads
- **User Threads**: 사용자 수준에서 관리되며, 주요 스레드 라이브러리로는 POSIX Pthreads, Windows threads, Java threads가 있음.
- **Kernel Threads**: 커널에서 지원하며, 대부분의 범용 운영 체제에서 지원됨 (예: Windows, Linux, Mac OS X, iOS, Android).

### 사용자 스레드와 커널 스레드의 관계
1. **Many to One**: 많은 사용자 수준 스레드가 하나의 커널 스레드에 매핑됨. 이 모델은 병렬 실행이 불가능하며, 예시로는 Solaris Green Threads, GNU Portable Threads가 있음.
2. **One to One**: 각 사용자 스레드가 커널 스레드에 매핑됨. 다중 코어에서 병렬로 실행할 수 있지만, 사용자 스레드의 수가 제한될 수 있음.
3. **Many to Many**: 여러 사용자 스레드가 여러 커널 스레드에 매핑될 수 있음. 이론적으로 병렬 실행이 가능하지만, 구현이 어려움.
4. **Two-level Model**: M:M 모델과 유사하나, 사용자 스레드가 커널 스레드에 바인딩될 수 있음.

## Thread Libraries

### 스레드 라이브러리
스레드 라이브러리는 프로그래머에게 스레드를 생성하고 관리할 수 있는 API를 제공함. 
- **POSIX Pthreads**: 사용자 수준 또는 커널 수준에서 제공됨.
- **Windows threads**: 커널 수준에서 지원됨.
- **Java threads**: 운영 체제에 따라 다름.

### 암시적 스레딩 (Implicit Threading)
- 스레드 수가 증가함에 따라 명시적 스레드 사용보다 암시적 스레드 사용이 인기를 끌고 있음.
- **Thread Pool**: 미리 스레드를 생성해두고 필요할 때 할당하여 사용함. 
  - 장점: 새로운 스레드를 생성하는 것보다 기존 스레드를 사용하는 것이 더 빠르며, 애플리케이션의 스레드 수를 풀의 크기로 제한할 수 있음.
- **Fork-Join Parallelism**: 여러 스레드를 생성(fork)하고, 작업이 완료되면 결합(join)하는 방식으로 병렬 처리를 수행함.
- **Grand Central Dispatch (GCD)**: Apple에서 제공하는 기술로, 병렬 실행이 가능한 코드를 지정하고 GCD가 스레드를 관리함.

## Threading Issues

### 시그널 처리 (Signal Handling)
- 시그널은 특정 이벤트가 발생했음을 프로세스에 알리는 데 사용됨. 단일 스레드 환경에서는 시그널이 프로세스에 전달됨.
- 멀티스레드 환경에서는 시그널을 특정 스레드에 전달하거나, 모든 스레드에 전달할 수 있음.

### 스레드 취소 (Thread Cancellation)
- **비동기 취소(Asynchronous cancellation)**: 대상 스레드를 즉시 종료함.
- **지연 취소(Deferred cancellation)**: 대상 스레드가 취소 지점에서 종료됨.

### 스레드 로컬 저장소 (Thread-Local Storage, TLS)
- 각 스레드가 고유한 데이터를 가질 수 있도록 허용하며, 함수 호출 간에도 유지되는 데이터임.

## Linux에서의 스레드 처리
- 리눅스에서는 스레드를 "태스크(task)"라고 부르며, 스레드 생성은 `clone()` 시스템 호출을 통해 이루어짐. 이 호출은 자식 태스크가 부모 태스크의 주소 공간을 공유할 수 있게 함.
- `task_struct` 구조체가 프로세스 데이터 구조를 가리키며, 프로세스 간에 공유되거나 고유하게 사용됨.

---