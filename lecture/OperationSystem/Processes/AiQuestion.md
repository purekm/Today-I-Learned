1. Context Switch와 시스템 성능

"Context switch가 발생할 때 '이전 프로세스의 상태를 PCB에 저장하고 새 프로세스의 상태를 로드한다'고 하셨습니다. 그렇다면 Context switch가 빈번하게 발생할 때 시스템 전체의 오버헤드가 증가하는 이유를 CPU 캐시(Cache) 관점에서 설명해 주실 수 있나요?"

=> Context Switching이 빈번하게 발생한다면 캐시오염이 발생함. CPU는 데이터 접근 속도를 올리려고 캐시에 담아두는데, context switching이 빈번하게 발생하면 필요한 데이터가 없으니까 메인메모리에서 필요한 데이터를 가져와야하는 cache miss가 많이 발생함.

2. 좀비 프로세스와 고아 프로세스의 관리

"자식 프로세스가 종료되었으나 부모가 wait()을 호출하지 않은 상태를 좀비 프로세스라고 정리하셨습니다. 좀비 프로세스가 시스템에 너무 많아지면 어떤 리소스 문제가 발생할 수 있으며, 이를 해결하기 위해 엔지니어로서 어떤 조치를 취해야 할까요?"

=> 좀비 프로세스는 이미 종료되었기 때문에 kill 할수가 없음. 그래서 부모 프로세스가 wait 하도록 시그널을 보내거나, 부모 프로세스도 죽여서 init프로세스가 수거하도록 함

3. IPC 방식의 선택 기준

"데이터 교환 방식으로 **공유 메모리(Shared Memory)**와 메시지 전달(Message Passing) 두 가지를 언급하셨습니다. 만약 매우 빈번하게 대량의 데이터를 주고받아야 하는 상황이라면, 두 방식 중 어떤 것이 더 유리할까요? 성능과 동기화 문제 측면에서 비교해 주세요."

=> 빈번하게 대량의 데이터를 공유해야 한다면 공유 메모리를 사용하는 것이 좋을 것 같음. message passing의 경우에는 시스템 콜이나 커널을 통한 복사 이런 오버헤드가 있을 수 있음. 따로 보낼 필요도 없고 한 곳에 저장해두고 사용한다면 성능이 좋아질 것 같지만, 동기화적인 측면에서는 공유하다보니 어느정도 lock이 필요할 것 같음

4. 컨테이너 환경에서의 프로세스 격리

"프로세스는 '집'이고 스레드는 '구성원'이라고 비유하셨습니다. 그렇다면 쿠버네티스의 Pod 내부에서 실행되는 여러 컨테이너들은 서로 프로세스 관점에서 어떤 자원을 공유할까요? 학습하신 IPC(Interprocess Communication) 개념 중 어떤 방식이 Pod 내 컨테이너 간 통신에 주로 사용될까요?"
=> pod내의 컨테이너들은 네트워크와 namespace를 공유함. 파일시스템의 경우 volume을 설정하면 공유

5. Lambda와 프로세스 생명 주기 (포트폴리오 기반)

"포트폴리오에서 Lambda의 콜드 스타트(Cold Start) 문제를 겪고 EC2로 전환하셨습니다. 운영체제의 프로세스 생성 관점에서 볼 때, Lambda가 함수를 처음 실행하기 위해 프로세스를 'New' 상태에서 'Running'까지 만드는 과정이 일반 프로세스 생성과 비교해 왜 더 오래 걸린다고 생각하시나요?"
=> 일반적으로는 명령어를 통해 바로 프로세스를 생성하지만, Lambda의 경우 가상머신을 생성하고 거기서 사용자의 코드 데이터를 다운해서 실행하는 방식이기 때문에 coldstart가 발생함

6. 가용성과 프로세스 종료 전략

"안드로이드 프로세스 관리 사례에서 중요도가 낮은 프로세스를 우선 종료한다고 하셨습니다. 이를 클라우드 분산 시스템에 적용해 본다면, 시스템 메모리가 부족할 때 운영체제(Linux 커널)가 특정 프로세스를 강제로 종료하는 'OOM(Out Of Memory) Killer' 메커니즘이 클라우드 서비스 안정성에 어떤 영향을 미칠지 설명해 보세요."
=> 우선순위가 낮은 프로세스를 제거하게 됨. k8s의 경우 resource에 limit을 걸 수 있어서 괜찮을 것 같음