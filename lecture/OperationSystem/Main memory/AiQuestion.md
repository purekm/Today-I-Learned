1. Segmentation vs Paging과 단편화(Fragmentation)

"메모리 할당 방식 중 Contiguous Allocation은 외부 단편화 문제를 일으킨다고 하셨습니다. 그렇다면 현대 OS가 사용하는 Paging 기법은 외부 단편화 문제를 어떻게 해결하며, 반대로 페이징 기법에서 발생할 수 있는 **Internal Fragmentation(내부 단편화)**은 어떤 상황에서 발생하는지 설명해 주세요."

=> 연속적 할당에서 외부 단편화 문제에 대한 해결 방안은 Paging. 물리 메모리를 고정된 크기의 프레임으로 나눠서 사용하도록 함. 내부 단편화는 프로세스의 크기가 페이지의 크기의 배수가 아닐 때 발생.

2. TLB(Translation Look-aside Buffer)의 역할

"메모리 접근 속도를 높이기 위해 TLB를 사용한다고 정리하셨습니다. 만약 Context Switch가 발생하여 실행 중인 프로세스가 바뀌었을 때, 기존에 TLB에 저장되어 있던 주소 변환 정보들은 어떻게 처리되어야 할까요? 만약 이를 처리하지 않는다면 어떤 보안 문제가 발생할 수 있을까요?"

=> 기존에 TLB에 저장되어있던 주소 변환 정보들 지우지 않을까 싶다. 다른 프로세스에서 TLB를 통해 논리주소로 물리 주소까지 접근하게 되면 보안상 문제가 있을 수 있을 것 같다.

3. Data 영역과 BSS 영역의 구분 이유

"초기값이 있는 변수(Data)와 없는 변수(BSS)를 구분하는 이유가 '메모리 최적화 및 I/O 효율' 때문이라고 아주 잘 답변하셨습니다. 그렇다면 실제 실행 파일(ELF 등)의 파일 크기 관점에서 볼 때, 대규모 배열을 전역 변수로 선언하되 '초기값을 주지 않은 경우'와 '모두 0으로 초기화한 경우' 중 어느 쪽이 파일 크기가 더 작을까요?"

=> 모두 0으로 초기화 한 파일이 더 크다.

4. 힙(Heap) 할당 방식과 성능 (mmap vs brk)

"작은 메모리는 brk()로, 큰 메모리는 mmap()으로 할당한다고 정리하셨습니다. 포트폴리오의 B2B 마케팅 플랫폼에서 대용량 데이터를 처리할 때, 빈번한 mmap 시스템 콜 발생이 서비스 응답 속도에 어떤 영향을 줄 수 있을까요? (참고: mmap은 heap 외부 영역을 할당함)"

=> 빈번하게 mmap이 발생한다면, 새로 외부의 공간을 생성하고 반납하는 시간이 발생해서 속도가 조금 느려질 것 같다.

5. Shared Pages와 컨테이너 효율성

"학습 내용 중 **Shared Code(Shared Pages)**에 대한 설명이 있습니다. 이를 컨테이너 환경에 대입해 본다면, 동일한 베이스 이미지(예: Ubuntu)를 사용하는 여러 개의 컨테이너가 하나의 노드에서 실행될 때, 메모리 효율성을 높이기 위해 운영체제 수준에서 이 개념이 어떻게 활용될 수 있을까요?"

=> 컨테이너들이 공통적으로 사용하는 라이브러리와 실행 코드를 물리 메모리에 저장을 해놓음으로써 각각 참조하게 만듦


