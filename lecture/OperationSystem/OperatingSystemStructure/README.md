Chapter2 <br/>
Objectives <br/>
1. 운영 체제가 제공하는 서비스 설명 <br/>
2. 운영 체제 서비스를 제공하기 위해 시스템 호출이 사용되는 방법<br/>
3. 단일형, 계층형, 마이크로 커널, 모듈형, 하이브리드 전략을 비교 <br/>
4. 운영 체제를 부팅하는 과정 설명 <br/>
5. 운영 체제 성능 모니터링 도구 적용 <br/>
6. 커널과 상호 작용하기 위한 커널 모듈 설계 및 구현 <br/>

운영체제가 제공하는 서비스 <br/>
-
1. User Interface - CLI, GUI, touch-screen, batch <br/>
2. Program execution - 메모리로 프로그램 load하고 실행시키기<br/>
3. I/O operations - 실행중인 프로그램이 필요한 I/O <br/>
4. File-system manipulation - 프로그램 파일과 디렉토리를 읽고 쓰는 등, 권한 관리 <br/>
5. Communication - 프로세스는 동일 컴퓨터 내에서나 네트워크를 통해 다른 컴퓨터간 정보 교환 <br/>
6. Error detection - 발생한 오류를 지속적으로 인지 <br/>
7. Resource allocation - 여러 사용자가 동시에 여러 작업을 실행할때, 각 사용자에게 필요한 자원을 할당시킴 <br/>
8. Logging - 어떤 사용자가 얼마나 많은 자원을 사용했는지 추적 <br/>
9. Protection and security - protection은 시스템 자원에 대한 접근을 통제하는 것이고, security는 외부로부터 시스템을 보호하는 것  <br/>

System call <br/>
-
System call은 운영 체제가 제공하는 서비스에 대한 프로그래밍 인터페이스로 API를 통해 접근 <br/>
![image](https://github.com/purekm/Today-I-Learned/assets/90774046/36e2ff18-658c-4f8a-9771-bee5f3f44cc6)<br/>

각 시스템 호출에는 연결된 번호와 그에 따른 테이블이 존재 <br/>
system call을 호출하고, system call의 상태 및 반환 값을 return <br/>

Interrupt call은 현재 register에 정보를 전부 저장하고 반납한 후, call이 끝나면 복구 <br/>

system call에는 단순히 원하는 system call의 식별 이상으로 많은 정보가 필요 <br/>
매개변수를 OS에 전달하는데 쓰는 방법 3개가 존재 <br/> 
1. 레지스터에 파라미터 전달 <br/>
2. 파라미터가 레지스터보다 많을 경우, 메모리 블록 or 테이블에 파라미터를 저장하고 블록의 주소를 레지스터에 저장 <br/>
3. 파라미터를 프로그램에 의해 스택에 놓고, 운영 체제에 의해 스택에서 pop <br/>
레지스터에 배열은 저장할 수 없는데, 배열을 저장해야 할 경우에는 주소를 저장함 <br/>

Linker and Loader <br/>
-
Linker 와 Loader은 컴파일된 프로그램을 실행 가능한 형태로 준비하는 역할 <br/>
Linker <br/>
1. 소스 코드는 개별적으로 컴파일되어 객체 파일이 됨 <br/>
2. 링커는 이 객체파일들을 하나의 binary 실행 파일로 결합 <br/>
3. 링커는 라이브러리를 가져와 프로그램에 포함시킴 <br/>

Loader <br/>
1. 프로그램은 binary 실행 파일 형태로 보조 기억 장치에 저장됨 <br/>
2. 이 파일을 메모리에 로드하여 실행 준비 <br/>

현대 범용 시스템에서는 라이브러리를 실행 파일에 포함시키지 않고, 필요할 때 동적으로 링크된 라이브러리를 로드 <br/>

운영 체제 설계 전략 <br/>
-
1. 단일형 (Monolithic) <br/>
   운영 체제의 모든 기능이 커널 공간에서 실행되는 구조 <br/>
   장점 - 모든 기능이 커널에서 실행되므로 시스템 호출간 오버헤드가 적고, 간단한 구현 <br/>
   단점 - 커널이 크고 복잡해질수록 디버깅과 유지 보수가 어려움 <br/>
2. 계층형 (Layered Approach) <br/>
   운영 체제를 계층으로 나누어 각 계층이 바로 아래 계층의 기능만을 사용하는 구조 <br/>
   장점 - 모듈화가 되어 있어 각 계층이 독립적으로 설계되고 구현 가능하여 유지보수가 편리하고, 오류가 다른 계층으로 전파되는 것을 막을 수 있음 <br/>
   단점 - 계층 간의 호출이 많아질수록 성능이 저하될 수 있고, 설계하기 복잡함 <br/>
3. 마이크로 커널 (Microkernel)<br/>
   최소한의 기능을 커널에 포함하고, 나머지 기능을 사용자 공간에서 실행가는 구조
   장점 - 확장성이 좋고, 사용자 공간에서 실행되는 서비스 간의 격리가 이루어져 안정성과 보안성이 높아짐<br/>
   단점 - 커널과 사용자 공간 간의 빈번한 통신으로 오버헤드 발생 가능하고, 구현하기 복잡함 <br/>
4. 모듈형 (Modular) <br/>
   커널을 여러 모듈로 나누어 필요한 모듈만 동적으로 로드하여 사용할 수 있는 구조 <br/>
   장점 - 필요에 따라 모듈을 추가하거나 제거할 수 있어 유연하고, 각 모듈이 독립적으로 개발되어 유지 보수가 용이함 <br/>
   단점 - 초기에 어떤 모듈이 필요한지 설계하기 복잡하고, 모듈 간의 인터페이스를 통해 호출이 이루어지므로 약간의 성능 저하가 있을 수 있음 <br/>
5. 하이브리드 (Hybrid) <br/>
   위의 구조들의 장점을 결합 <br/>
   장점 - 최적화된 성능 <br/>
   단점 - 설계하기 복잡합 <br/>

System boot <br/>
-
1. 전원이 켜지면 실행이 고정된 메모리 위치에서 시작됨 <br/>
2. 운영 체제를 하드웨어에서 사용할 수 있도록 bootstrap loader에 의해 수행됨<br/>
3. Bootstrap loader는 운영 체제 커널을 찾고, 이를 메모리에 로드하여 실행을 시작 <br/>
4. 시스템이 실행되기 시작하면 커널은 하드웨어 초기화 및 자원할당을 수행하고, 기본 프로세스 및 데몬을 시작 <br/>
