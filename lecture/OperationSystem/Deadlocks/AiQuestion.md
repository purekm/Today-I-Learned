1. Livelock과 Deadlock의 차이

"Livelock을 '계속 시도해도 진행이 안 되는 경우'라고 정리하셨습니다. 그렇다면 프로세스가 아무것도 하지 못하고 멈춰있는 Deadlock과 비교했을 때, CPU 리소스 소모 측면에서 Livelock은 어떤 특징을 가지며 왜 더 위험할 수 있을까요?"

=> Livelock은 계속 진행을 하고 있는 cycle 느낌으로, CPU리소스를 더 소모하며, deadlock은 자원이 없어서 대기하고 있는 상태로 CPU를 소모하지 않고 있는 상태인가..?

2. 자원 할당 그래프(RAG) 분석

"Single instance일 경우 'Cycle이면 Deadlock'이라고 하셨습니다. 그렇다면 Multiple instance 환경에서 사이클(Cycle)이 발견되었음에도 불구하고 데드락이 발생하지 않을 수 있는 시나리오는 무엇인가요? 그래프의 관점에서 설명해 주세요."

=> 여러 인스턴스가 있는 환경에서는 싸이클이 존재해도, 싸이클 외부의 프로세스가 자원을 반납할 가능성이 있기 때문이다.

3. 가장 현실적인 예방책: Circular Wait 차단

"자원에 순서를 부여하여 순차적으로 요청하게 함으로써 순환 대기를 막는 방식이 가장 현실적이라고 하셨습니다. 하지만 이 방식이 새로운 자원(Resource)이 시스템에 추가되거나 프로그램의 유연성이 필요한 상황에서 가질 수 있는 단점은 무엇일까요?"

=> 새로운 자원이 추가되면 자원에 대한 우선순위를 새롭게 정의해야 함

4. 분산 시스템에서의 데드락

"포트폴리오의 B2B 마케팅 플랫폼 구조를 보면 S3, RDS, Lambda 등 여러 AWS 서비스가 상호작용합니다. 만약 두 개의 프로세스가 각각 서로 다른 DB Table에 Lock을 건 채 상대방의 자원을 기다리는 상황이 발생한다면, OS 수준의 데드락 해결법 중 어떤 방식을 클라우드 아키텍처에 적용하는 것이 가장 효율적일까요?"
=>

5. Banker’s Algorithm의 한계

"Banker’s Algorithm은 프로세스의 **최대 자원 요구량(Max)**을 미리 알아야 합니다. 하지만 AWS Lambda처럼 트래픽에 따라 동적으로 실행되는 서버리스 환경에서, 모든 함수의 최대 자원 요구량을 사전에 정확히 선언하고 할당하는 것이 현실적으로 어려운 이유는 무엇일까요?"

6. Recovery 전략 선택

"데드락 복구를 위해 프로세스를 **Abort(종료)**하거나 **Preemption(자원 탈취)**을 한다고 하셨습니다. 만약 중요한 결제 데이터를 처리하는 프로세스가 데드락에 걸렸다면, 시스템 안정성을 위해 '모두 죽이기'와 '하나씩 죽이기' 중 어떤 전략을 택하시겠습니까? 그 이유를 데이터 무결성 관점에서 설명해 보세요."