
---

# Chapter 5 - Overview

## Objectives
1. 다양한 CPU 스케줄링 알고리즘을 설명
2. 스케줄링 기준에 따라 CPU 스케줄링 알고리즘을 평가
3. 다중 프로세서 및 멀티코어 스케줄링 관련 문제 설명
4. 다양한 실시간 스케줄링 알고리즘 설명
5. Windows와 Linux 운영 체제에서 사용되는 스케줄링 알고리즘 설명
6. CPU 스케줄링 알고리즘을 평가하기 위해 모델링 및 시뮬레이션 적용

## Basic Concepts

### 개요
- **CPU 최대 활용**은 다중 프로그래밍으로 달성됨.
- **CPU-I/O 버스트 주기**: 프로세스 실행은 CPU 실행과 I/O 대기 주기의 반복으로 구성됨.
- **CPU 스케줄러**는 준비 큐에서 프로세스를 선택해 CPU 코어를 할당.
- 스케줄링 결정은 프로세스가 실행 중지, 준비 상태로 전환, 대기 상태로 전환, 종료될 때 발생.

### 스케줄링 기준
- **CPU 이용률**: CPU를 최대한 바쁘게 유지.
- **처리량**: 단위 시간당 완료된 프로세스 수.
- **반환 시간**: 특정 프로세스를 실행하는 데 걸리는 시간.
- **대기 시간**: 프로세스가 준비 큐에서 대기한 시간.
- **응답 시간**: 요청이 제출된 후 첫 응답이 생성될 때까지 걸리는 시간.

## Scheduling Algorithms

### FCFS (First-Come, First-Served) Scheduling
- 프로세스가 도착한 순서대로 CPU를 할당.
- 간단하지만 **Convoy Effect**라는 단점이 있음: 긴 CPU 바운드 작업이 짧은 작업을 지연시킴.

### SJF (Shortest-Job-First) Scheduling
- 다음 CPU 버스트 시간이 가장 짧은 프로세스에 CPU를 할당.
- **최소 평균 대기 시간**을 제공하지만, 다음 CPU 버스트 시간을 예측하는 것이 어려움.

### Round Robin (RR) Scheduling
- 각 프로세스에 동일한 양의 CPU 시간을 순환적으로 할당.
- 타임 퀀텀이 클 경우 FCFS와 유사하며, 작을 경우 문맥 전환 오버헤드가 증가.

### Priority Scheduling
- 각 프로세스에 우선 순위를 부여하고, 높은 우선 순위를 가진 프로세스에 CPU를 할당.
- **Starvation** 문제 발생 가능: 낮은 우선 순위 프로세스가 실행되지 않을 수 있음.
- **Aging** 기법으로 해결 가능: 시간이 지남에 따라 프로세스의 우선 순위를 증가시킴.

### Multilevel Queue Scheduling
- 여러 개의 큐를 사용해 각 큐에 우선 순위를 부여.
- 높은 우선 순위 큐의 프로세스를 먼저 스케줄링.

### Multilevel Feedback Queue Scheduling
- 프로세스가 큐 사이를 이동할 수 있도록 허용하여, CPU 사용량에 따라 프로세스를 상위 또는 하위 큐로 이동.
- 복잡하지만 매우 일반적인 스케줄링 알고리즘.

## Thread Scheduling

### 사용자 스레드와 커널 스레드
- 사용자 스레드는 사용자 수준에서 관리되는 스레드로, 라이브러리에서 직접 관리. 오버헤드가 적지만, 커널에서 인식되지 않기 때문에 커널의 자원을 공유할 수 없음.
- 커널 스레드는 운영체제의 커널에 의해 관리되는 스레드로, 스케줄러에 의해 관리. 모든 시스템 자원에 접근할 수 있음.
- **Process-Contention Scope (PCS)**: 사용자 수준 스레드가 프로세스 내에서 경쟁하는 방식.
- **PCS**는 주로 Many-to-One 혹은 Many-to-Many 모델에서 사용. 스레드의 스케줄링이 프로세스 내부에서 발생하므로 커널은 사용자 스레드의 존재를 인지하지 못함.
- **System-Contention Scope (SCS)**: 커널 수준 스레드가 시스템 전체에서 경쟁.
- **SCS**는 One-to-One 스레딩 모델에서 주로 사용. 각 사용자 스레드가 커널 스레드로 매핑되기 때문에, 커널 스레드들이 시스템 전체에서 스케줄링되며 독립적으로 동작할 수 있게됨. 따라서 시스템의 자원을 공유하며 경쟁.

## Multi-Processor Scheduling

### 다중 프로세서 스케줄링
- **대칭 다중처리 (SMP)**: 각 프로세서가 자체적으로 스케줄링.
- - common ready queue 방식 : readyqueue를 공유하기 때문에 부하분산은 자동으로 되지만, race condition이 발생가능
- - per-core run queue 방식 : lock 경합이 낮아지고, 캐시지역성이 높아짐. 하지만 코어에 많은 작업이 몰릴 수 있으므로 로드밸런싱이 필요함.
- **부하 분산 (Load Balancing)**: 모든 CPU가 균등하게 로드되도록 시도.
- **프로세서 친화성 (Processor Affinity)**: 특정 프로세서에서 실행된 스레드가 다시 동일한 프로세서에서 실행되도록 하면 캐시 재사용으로 유리함
- **SMT(Stimultaneous Multithreading)**: 하나의 물리 코어가 여러개의 하드웨어 스레드(논리적인 코어)를 동시에 돌리는 기술


### 멀티코어 프로세서
- 최근 트렌드: 동일한 물리적 칩에 여러 프로세서 코어를 배치.
- 메모리 대기 시간 동안 다른 스레드가 실행되도록 하여 효율성 증가.

### NUMA-aware
- Non Uniform Memory Access라는 의미로, 해당 노드의 메모리에는 빠르게 다른 노드의 원격 메모리에는 느리게 접근되는 구조를 뜻함
- 스레드가 쓰는 데이터와 같은 노드에서 돌게 하는 것

### 흐름 정리
1. CPU는 한번에 하나의 스레드만 실행. 스레드 스케줄링은 누가 언제 얼마나 CPU를 사용할지 결정하는 것(스케줄링을 통해 병행하는 것 처럼 보임)
2. 멀티스레딩은 다중 코어 환경에서는 프로세스의 스레드들을 병렬로 사용(단일 코어에서는 병행만 되기도 함. SMT를 사용하면 코어가 1개여도 하드웨어 스레드가 2개가 되면 병렬가능)
3. 멀티코어 프로세싱은 
## Real-Time CPU Scheduling

### 실시간 스케줄링

### Event Latency
- **이벤트 지연(Event Latency)**: 이벤트 발생 시점부터 해당 이벤트가 서비스되기까지의 지연 시간.
  - **인터럽트 지연(Interrupt Latency)**: 인터럽트가 발생한 후, 인터럽트 핸들러가 실행되기 시작할 때까지 걸리는 시간.
  - **디스패치 지연(Dispatch Latency)**: CPU를 현재 작업에서 다른 작업으로 전환하는 데 걸리는 시간.
  - 이벤트 지연은 특히 하드 실시간 시스템에서 중요한 문제이며, 이러한 지연을 줄이는 것이 성능 향상의 핵심 요소입니다.

### Priority-Based Scheduling (우선순위 기반 스케줄링)
- 실시간 스케줄링에서 중요한 개념으로, 높은 우선순위 작업이 CPU를 우선적으로 사용.
- **Soft Real-Time Systems**: 우선순위가 높은 실시간 작업이 먼저 실행되지만, 언제 실행될지 보장되지 않음.
- **Hard Real-Time Systems**: 작업이 반드시 정해진 데드라인 안에 완료되어야 함.
  - 주기적 작업(Periodic Task)은 일정한 간격으로 CPU를 요구하며, 이때 우선순위 스케줄링이 필요함.

### Rate Monotonic Scheduling (비율 모노토닉 스케줄링, RMS)
- **비율 모노토닉 스케줄링**: 작업의 주기가 짧을수록 높은 우선순위를 부여하는 정적 우선순위 스케줄링 방식.
  - 주기가 짧은 작업이 더 자주 실행되어야 하므로, 더 높은 우선순위를 가지게 됨.
  - RMS는 정적 우선순위를 기반으로 하며, 주기가 고정된 작업들을 효과적으로 스케줄링할 수 있음.

### Earliest Deadline First (EDF) Scheduling
- **Earliest Deadline First (EDF)**: 데드라인이 가장 가까운 작업에 우선적으로 CPU를 할당하는 동적 우선순위 스케줄링 알고리즘.
  - EDF는 작업의 데드라인에 따라 우선순위가 결정되므로, 하드 실시간 시스템에 적합.
  - 스케줄링 시점마다 작업의 데드라인을 기준으로 우선순위를 재조정하여 가장 긴급한 작업을 먼저 처리함.

### Proportional Share Scheduling (비례 공유 스케줄링)
- **Proportional Share Scheduling**: 시스템 자원의 사용 비율을 기반으로 CPU 시간을 할당하는 방식.
  - 각 프로세스에 할당된 비율에 따라 CPU 시간을 나누어 주는 방식으로, 자원의 공정한 분배를 보장함.
  - 네트워크에서 사용되는 **Weighted Fair Queuing (WFQ)**과 유사한 원리로 동작.

### Real-Time Scheduling Challenges (실시간 스케줄링의 도전 과제)
- **자원 접근 문제(Resource Access Issues)**: 여러 실시간 작업이 동시에 자원을 요구할 때, 자원의 충돌을 피하고 적절하게 분배하는 것이 중요.
  - 자원 할당이 잘못되면 실시간 작업이 데드라인을 놓칠 수 있음.
- **우선순위 역전(Priority Inversion)**: 낮은 우선순위 작업이 높은 우선순위 작업보다 자원을 먼저 점유하게 되는 상황.
  - 우선순위 역전은 중요한 실시간 작업의 지연을 초래할 수 있음.
  
### Priority Inheritance (우선순위 상속)
- **우선순위 상속(Priority Inheritance)**: 우선순위 역전 문제를 해결하기 위한 메커니즘.
  - 자원을 점유한 낮은 우선순위 작업이 높은 우선순위 작업의 우선순위를 상속받아 우선적으로 실행됨.
  - 이를 통해 높은 우선순위 작업이 가능한 한 빨리 자원을 획득하고 데드라인을 지킬 수 있도록 함.

### Windows and Linux Real-Time Scheduling
- **Windows**: Windows 운영 체제는 **Real-Time Priority Class**를 통해 실시간 작업을 위한 우선순위 기반 스케줄링을 지원.
  - 우선순위가 높은 작업은 항상 먼저 처리되며, 실시간 작업의 수행을 보장하기 위해 특수한 스케줄링 메커니즘이 포함됨.
- **Linux**: Linux는 **POSIX.1b** 실시간 확장을 지원하며, FIFO(First-In-First-Out)와 Round Robin 방식의 스케줄링을 제공.
  - **Earliest Deadline First (EDF)**와 같은 동적 스케줄링 알고리즘을 통해 실시간 작업의 데드라인 준수를 지원.

---

윈도우에서는 우선순위 기반 Realtime Scheduling
리눅스에서는 FIFO, EDF, RR 등 다양한 스케줄링 기법 제공
 